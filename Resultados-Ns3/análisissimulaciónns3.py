# -*- coding: utf-8 -*-
"""AnálisisSimulaciónNs3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12GSV9-hVu4z82PqimSbzWwQsaGry9ILN
"""

import pandas as pd
import matplotlib.pyplot as plt
import re
import numpy as np

# Cargar el archivo como UTF-16 sin delimitador
df = pd.read_csv('/content/output.csv', encoding='utf-16', header=None)

# Mostrar las primeras filas del DataFrame
print(df.head())

# Ver la estructura del DataFrame
print(df.info())

# Separar la única columna en dos partes: Timestamp y Data
df[['Timestamp', 'Data']] = df[0].str.extract(r'(\+ \d+\.\d+|\d+) (.*)')

# Mostrar las primeras filas del nuevo DataFrame
print(df[['Timestamp', 'Data']].head())

# Limpiar el Timestamp
df['Timestamp'] = df['Timestamp'].str.replace('+', '').astype(float)

# Mostrar las primeras filas para verificar la limpieza
print(df[['Timestamp', 'Data']].head())

# Función para extraer información
def extract_info(row):
    # Regex para capturar las direcciones IP
    ip_pattern = r'(\d+\.\d+\.\d+\.\d+)'
    port_pattern = r'(\d+)'

    ips = re.findall(ip_pattern, row['Data'])
    ports = re.findall(port_pattern, row['Data'])

    # Obtener el tipo de paquete (por ejemplo, SYN, ACK)
    packet_type = re.search(r'\[(.*?)\]', row['Data'])
    packet_type = packet_type.group(1) if packet_type else None

    return pd.Series([ips, ports, packet_type])

# Aplicar la función a cada fila
df[['IPs', 'Ports', 'PacketType']] = df.apply(extract_info, axis=1)

# Mostrar el DataFrame con la nueva información
print(df[['Timestamp', 'IPs', 'Ports', 'PacketType']].head())

# Extraer puertos de interés (por ejemplo, puertos de origen y destino)
df['SourcePorts'] = df['Ports'].apply(lambda x: x[0:len(x)//2])  # Asumiendo que la primera mitad son puertos de origen
df['DestPorts'] = df['Ports'].apply(lambda x: x[len(x)//2:])  # Y la segunda mitad son puertos de destino

# Mostrar el DataFrame con la nueva información
print(df[['Timestamp', 'IPs', 'SourcePorts', 'DestPorts', 'PacketType']].head())

# Contar la cantidad de paquetes por timestamp
traffic_per_second = df['Timestamp'].value_counts().sort_index()

# Visualizar el tráfico
traffic_per_second.plot(kind='line', title='Tráfico por Segundo')
plt.xlabel('Timestamp')
plt.ylabel('Cantidad de Paquetes')
plt.xticks(rotation=45)
plt.show()

# Contar la cantidad de cada tipo de paquete
packet_counts = df['PacketType'].value_counts()

# Visualizar los conteos
import matplotlib.pyplot as plt

packet_counts.plot(kind='bar', title='Conteo de Tipos de Paquetes')
plt.xlabel('Tipo de Paquete')
plt.ylabel('Cantidad')
plt.xticks(rotation=45)
plt.show()

# Filtrar por una dirección IP específica (por ejemplo, 10.1.1.1)
specific_ip_traffic = df[df['IPs'].apply(lambda x: '10.1.1.1' in x)]

# Mostrar el tráfico de la IP específica
print(specific_ip_traffic)

ip_counts = df['IPs'].explode().value_counts()
print(ip_counts)

# Contar puertos de origen
source_ports_counts = df['SourcePorts'].explode().value_counts()
print(source_ports_counts)

# Contar puertos de destino
dest_ports_counts = df['DestPorts'].explode().value_counts()
print(dest_ports_counts)

# Graficar el conteo de paquetes por IP
ip_counts.plot(kind='bar', title='Conteo de Paquetes por IP')
plt.xlabel('IP')
plt.ylabel('Cantidad de Paquetes')
plt.xticks(rotation=45)
plt.show()

syn_packets = df[df['PacketType'] == 'SYN']
print(syn_packets)

# Agrupar por intervalos de tiempo (ej. cada 0.1 segundos)
traffic_per_interval = df.groupby(pd.cut(df['Timestamp'].astype(float), bins=np.arange(0, df['Timestamp'].astype(float).max(), 0.1))).size()

# Visualizar el tráfico por intervalo
traffic_per_interval.plot(kind='line', title='Tráfico por Intervalo de Tiempo')
plt.xlabel('Intervalo de Tiempo')
plt.ylabel('Cantidad de Paquetes')
plt.show()

# Agrupar los datos por intervalos de tiempo
traffic_per_interval = df.groupby(pd.cut(df['Timestamp'].astype(float),
                                           bins=np.arange(0, df['Timestamp'].astype(float).max(), 0.1),
                                           include_lowest=True)).size()

# Visualizar el tráfico
traffic_per_interval.plot(kind='line', title='Tráfico por Intervalo')
plt.xlabel('Intervalo de Tiempo')
plt.ylabel('Cantidad de Paquetes')
plt.xticks(rotation=45)
plt.show()

import matplotlib.pyplot as plt

traffic_per_second = df.groupby('Timestamp').size()
traffic_per_second.plot(kind='line', title='Tráfico por Segundo')
plt.xlabel('Timestamp')
plt.ylabel('Cantidad de Paquetes')
plt.xticks(rotation=45)
plt.show()

ip_activity = df['IPs'].value_counts().head(10)
print(ip_activity)

from collections import Counter

ip_pairs = Counter(tuple(sorted(pair)) for pair in df['IPs'])
print(ip_pairs.most_common(10))

port_usage = df['Ports'].explode().value_counts().head(10)
print(port_usage)

port_usage.plot(kind='bar', title='Puertos Más Utilizados')
plt.xlabel('Puerto')
plt.ylabel('Frecuencia')
plt.show()

traffic_per_interval = df.groupby(pd.cut(df['Timestamp'].astype(float), bins=np.arange(0, df['Timestamp'].astype(float).max(), 0.1))).size()
traffic_per_interval.plot(kind='bar', title='Tráfico por Intervalo')
plt.xlabel('Intervalo de Tiempo')
plt.ylabel('Cantidad de Paquetes')
plt.show()

# Aplanar la columna de IPs
df_exploded = df.explode('IPs')

# Ahora agrupar por Timestamp y IPs
heatmap_data = df_exploded.groupby(['Timestamp', 'IPs']).size().unstack(fill_value=0)

# Crear el gráfico de calor
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 8))
sns.heatmap(heatmap_data, cmap='YlGnBu', annot=True)
plt.title('Gráfico de Calor de Tráfico por IPs')
plt.xlabel('IPs')
plt.ylabel('Timestamp')
plt.xticks(rotation=45)
plt.show()

df.describe()

# Crear una nueva columna para contar retransmisiones
df['RetransmissionCount'] = 0

# Suponiendo que los datos tienen columnas 'Timestamp', 'IPs', 'Ports', y 'PacketType'
for i, row in df.iterrows():
    # Filtrar los paquetes que coinciden con la IP y el puerto
    retransmissions = df[(df['IPs'].apply(lambda x: row['IPs'][0] in x)) &
                         (df['Ports'].apply(lambda x: row['Ports'][0] in x)) &
                         (df['Timestamp'] > row['Timestamp'] - 1) &  # Ejemplo de ventana de 1 segundo
                         (df['Timestamp'] < row['Timestamp'])]

    # Actualizar el conteo de retransmisiones
    df.at[i, 'RetransmissionCount'] = len(retransmissions)

# Visualizar el conteo de retransmisiones
retransmission_counts = df['RetransmissionCount'].value_counts()
retransmission_counts.plot(kind='bar', title='Conteo de Retransmisiones')
plt.xlabel('Cantidad de Retransmisiones')
plt.ylabel('Frecuencia')
plt.show()

# Separar la única columna en dos partes: Timestamp y Data
df[['Timestamp', 'Data']] = df[0].str.extract(r'(\+ \d+\.\d+|\d+) (.*)')
df['Timestamp'] = df['Timestamp'].str.replace('+', '').astype(float)

# Función para extraer IPs y Puertos
def extract_info(row):
    ip_pattern = r'(\d+\.\d+\.\d+\.\d+)'
    port_pattern = r'(\d+)'
    ips = re.findall(ip_pattern, row['Data'])
    ports = re.findall(port_pattern, row['Data'])
    return pd.Series([ips, ports])

df[['IPs', 'Ports']] = df.apply(extract_info, axis=1)

# Análisis de retransmisiones
retransmissions = []

# Definir un intervalo de tiempo para considerar retransmisiones (ej. 1 segundo)
time_window = 1.0

# Iterar sobre cada fila del DataFrame
for i, row in df.iterrows():
    # Filtrar los paquetes que coinciden con la IP y el puerto en la ventana de tiempo
    retransmitted_packets = df[
        (df['IPs'].apply(lambda x: row['IPs'][0] in x)) &  # Coincidencia de IPs
        (df['Ports'].apply(lambda x: row['Ports'][0] in x)) &  # Coincidencia de Puertos
        (df['Timestamp'] > row['Timestamp'] - time_window) &  # Ventana de tiempo
        (df['Timestamp'] < row['Timestamp'])
    ]

    # Contar las retransmisiones
    retransmission_count = len(retransmitted_packets)
    retransmissions.append(retransmission_count)

# Añadir el conteo de retransmisiones al DataFrame
df['RetransmissionCount'] = retransmissions

# Resumir el conteo de retransmisiones
retransmission_summary = df['RetransmissionCount'].value_counts().sort_index()

# Visualizar el conteo de retransmisiones
plt.figure(figsize=(10, 6))
retransmission_summary.plot(kind='bar', title='Conteo de Retransmisiones por Paquete')
plt.xlabel('Cantidad de Retransmisiones')
plt.ylabel('Frecuencia')
plt.xticks(rotation=0)
plt.grid(axis='y')
plt.show()

# Filtrar paquetes que han sido retransmitidos al menos una vez
retransmitted_packets_df = df[df['RetransmissionCount'] > 0]

# Mostrar un resumen de los paquetes retransmitidos
print(retransmitted_packets_df[['Timestamp', 'IPs', 'Ports', 'RetransmissionCount']].head())

# Resumir el conteo de retransmisiones en intervalos
retransmission_intervals = pd.cut(df['RetransmissionCount'], bins=[0, 1, 3, 5, 10, np.inf],
                                   labels=['0', '1-3', '4-5', '6-10', '10+'])
retransmission_summary = retransmission_intervals.value_counts().sort_index()

# Visualizar el conteo de retransmisiones usando un gráfico de barras
plt.figure(figsize=(10, 6))
retransmission_summary.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Conteo de Retransmisiones por Paquete')
plt.xlabel('Cantidad de Retransmisiones')
plt.ylabel('Frecuencia')
plt.xticks(rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Agrupar retransmisiones por intervalos de tiempo
traffic_per_interval = df.groupby(pd.cut(df['Timestamp'], bins=np.arange(0, df['Timestamp'].max(), 1))).size()

# Visualizar el tráfico de retransmisiones por intervalo de tiempo
plt.figure(figsize=(12, 6))
plt.plot(traffic_per_interval.index.categories.mid, traffic_per_interval.values, marker='o', color='orange')
plt.title('Tráfico de Retransmisiones por Intervalo de Tiempo')
plt.xlabel('Intervalo de Tiempo (s)')
plt.ylabel('Cantidad de Retransmisiones')
plt.xticks(rotation=45)
plt.grid()
plt.tight_layout()
plt.show()

# Calcular la cantidad de paquetes retransmitidos y no retransmitidos
total_packets = len(df)
retransmitted_count = df[df['RetransmissionCount'] > 0].shape[0]  # Paquetes que han sido retransmitidos
not_retransmitted_count = total_packets - retransmitted_count  # Paquetes que no han sido retransmitidos

# Asegurarse de que los conteos sean no negativos
if not_retransmitted_count < 0:
    not_retransmitted_count = 0

# Preparar los datos para el gráfico de pastel
labels = ['Retransmitidos', 'No Retransmitidos']
sizes = [retransmitted_count, not_retransmitted_count]
colors = ['lightcoral', 'lightskyblue']
explode = (0.1, 0)  # Explode el primer segmento

# Visualizar el gráfico de pastel
plt.figure(figsize=(8, 8))
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
        shadow=True, startangle=90)
plt.axis('equal')  # Para que el gráfico sea un círculo
plt.title('Proporción de Paquetes Retransmitidos vs. No Retransmitidos')
plt.show()